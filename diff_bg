diff --git a/source/background.c b/source/background.c
index e0a6d227..3b700717 100755
--- a/source/background.c
+++ b/source/background.c
@@ -499,18 +499,17 @@ int background_functions(
     }
     else
     {
-      /* NEDE decay phase with w > 0 */
+      /* decay phase with w > 0 */
 
+      // printf("here");
       class_call(background_quantities_NEDE(pba, a_rel, 0, &rho_NEDE_decay, NULL, &w_NEDE, &dw_over_da_NEDE, NULL),
                  pba->error_message,
                  pba->error_message);
 
       pvecback[pba->index_bg_rho_NEDE] = rho_NEDE_decay;
-
       pvecback[pba->index_bg_w_NEDE] = w_NEDE;
       p_tot += w_NEDE * rho_NEDE_decay;
       rho_tot += rho_NEDE_decay;
-
       dp_dloga += (a * dw_over_da_NEDE - 3 * (1 + w_NEDE) * w_NEDE) * pvecback[pba->index_bg_rho_NEDE];
     }
   }
@@ -693,63 +692,45 @@ int background_w_fld(
 }
 
 /**
- * Single place where the NEDE fluid equation of state is
+ * Single place where the fluid equation of state is
  * defined. Parameters of the function are passed through the
  * background structure. Generalisation to arbitrary functions should
  * be simple.
  *
  * @param pba            Input: pointer to background structure
  * @param a              Input: current value of scale factor
- * @param a_prime_over_a Input: Hubble parameter
- * @param rho             Output: rho_NEDE(a)
- * @param p               Output: p_NEDE(a)
- * @param w               Output: equation of state parameter w_NEDE(a)
- * @param dw_over_da      Output: function dw_NEDE/da
- * @param ca2             Output: adiabatic sound speed$
+ * @param w_NEDE          Output: equation of state parameter w_fld(a)
+ * @param dw_over_da_NEDE Output: function dw_fld/da
+ * @param integral_NEDE   Output: function \f$ \int_{a}^{a_0} da 3(1+w_{fld})/a \f$
  * @return the error status
  */
 
-int background_quantities_NEDE(
+/*
+int background_w_NEDE(
     struct background *pba,
     double a,
-    double a_prime_over_a,
-    double *rho,
-    double *p,
-    double *w,
-    double *dw_over_da,
-    double *ca2)
+    double *w_NEDE,
+    double *dw_over_da_NEDE)
 {
-  double x, a_over_a_non_rel;
-  double rhohat, phat, drhohat_dx, dphat_dx;
-  int last_index_1 = 1, last_index_2, i;
-  double w_prime;
+
   double w_local = 0.;
-  double rho_local, dw_over_da_local;
-  double *vec;
 
   switch (pba->NEDE_fld_nature)
   {
   case NEDE_fld_A:
-    w_local = pba->three_eos_NEDE / 3.;
-    rho_local = (pba->Omega_NEDE) * pow(pba->H0, 2) * pow(pba->a_decay / a, 3. + 3. * w_local);
-    w_prime = 0.;
-
-    if (w != NULL)
-      *w = w_local;
-    if (dw_over_da != NULL)
-      *dw_over_da = 0;
-    if (rho != NULL)
-      *rho = rho_local;
-    if (p != NULL)
-      *p = w_local * rho_local;
-    if ((ca2 != NULL) && (a_prime_over_a != 0.))
-      *ca2 = w_local - w_prime / 3. / (1. + w_local) / a_prime_over_a;
-
+    *w_NEDE = pba->three_eos_NEDE / 3.;
+    *dw_over_da_NEDE = 0;
+    break;
+  case NEDE_fld_B:
+    w_local = 1 / 3. * 1. / (1. + pow(a * pba->mass_over_q0_NEDE, 2));
+    *w_NEDE = w_local;
+    *dw_over_da_NEDE = -6. * a * pow(pba->mass_over_q0_NEDE * w_local, 2);
     break;
   }
 
   return _SUCCESS_;
 }
+*/
 
 /**
  * Initialize the background structure, and in particular the
@@ -1002,6 +983,19 @@ int background_free_input(
       free(pba->ncdm_psd_parameters);
   }
 
+  if ((pba->Omega_NEDE > 0) || (pba->f_NEDE > 0))
+  {
+    if (pba->NEDE_fld_nature == NEDE_fld_BIII)
+    {
+      free(pba->dist_table);
+      free(pba->d2dist_dx2_table);
+      free(pba->d2x_da2_table);
+      free(pba->x_values);
+      free(pba->a_over_a_non_rel_table);
+      free(pba->NEDE_vec);
+    }
+  }
+
   if (pba->Omega0_scf != 0.)
   {
     if (pba->scf_parameters != NULL)
@@ -1170,7 +1164,6 @@ int background_indices(
      normal vector */
   /* - index for NEDE   */
   class_define_index(pba->index_bg_rho_NEDE, pba->has_NEDE, index_bg, 1);
-  /* - index for NEDE eos   */
   class_define_index(pba->index_bg_w_NEDE, pba->has_NEDE, index_bg, 1);
   /* - index for trigger   */
   class_define_index(pba->index_bg_phi_trigger, pba->has_NEDE_trigger, index_bg, 1);
@@ -1454,6 +1447,237 @@ int background_ncdm_test_function(
   return _SUCCESS_;
 }
 
+int background_quantities_NEDE(
+    struct background *pba,
+    double a,
+    double a_prime_over_a,
+    double *rho,
+    double *p,
+    double *w,
+    double *dw_over_da,
+    double *ca2)
+{
+  double x, a_over_a_non_rel;
+  double rhohat, phat, drhohat_dx, dphat_dx;
+  int last_index_1 = 1, last_index_2, i;
+  double w_prime;
+  double w_local = 0.;
+  double rho_local, dw_over_da_local;
+  double *vec;
+
+  switch (pba->NEDE_fld_nature)
+  {
+  case NEDE_fld_A:
+    w_local = pba->three_eos_NEDE / 3.;
+    rho_local = (pba->Omega_NEDE) * pow(pba->H0, 2) * pow(pba->a_decay / a, 3. + 3. * w_local);
+    w_prime = 0.;
+
+    if (w != NULL)
+      *w = w_local;
+    if (dw_over_da != NULL)
+      *dw_over_da = 0;
+    if (rho != NULL)
+      *rho = rho_local;
+    if (p != NULL)
+      *p = w_local * rho_local;
+    if ((ca2 != NULL) && (a_prime_over_a != 0.))
+      *ca2 = w_local - w_prime / 3. / (1. + w_local) / a_prime_over_a;
+
+    break;
+
+  case NEDE_fld_B:
+    w_local = 1 / 3. * 1. / (1. + pow(a * pba->mass_over_q0_NEDE, 2));
+    rho_local = (pba->Omega_NEDE) * pow(pba->H0, 2) * pow(pba->a_decay / a, 4.) * pow((1. + pow(pba->mass_over_q0_NEDE * a, 2)) / (1. + pow(pba->mass_over_q0_NEDE * pba->a_decay, 2)), 0.5);
+    dw_over_da_local = -6. * a * pow(pba->mass_over_q0_NEDE * w_local, 2);
+
+    if (w != NULL)
+      *w = w_local;
+    if (*dw_over_da = !NULL)
+      *dw_over_da = dw_over_da_local;
+    if (rho != NULL)
+      *rho = rho_local;
+    if (p != NULL)
+      *p = w_local * rho_local;
+    if (ca2 != NULL)
+      *ca2 = w_local;
+    break;
+
+  case NEDE_fld_BIII:
+
+    class_alloc(vec, sizeof(double) * 8, pba->error_message);
+    a_over_a_non_rel = a / pba->a_non_rel;
+
+    if ((a_over_a_non_rel < pba->a_over_a_non_rel_max) && (a_over_a_non_rel > pba->a_over_a_non_rel_min))
+    {
+      // printf("a_over_a_non_rel: %f",a_over_a_non_rel);
+
+      class_call(array_interpolate_spline(
+                     pba->a_over_a_non_rel_table,
+                     pba->size_x,
+                     pba->x_values,
+                     pba->d2x_da2_table,
+                     1,
+                     a_over_a_non_rel,
+                     &last_index_1,
+                     &x,
+                     1,
+                     pba->error_message),
+                 pba->error_message,
+                 pba->error_message);
+
+      // printf("last index: %d \n", last_index_1);
+      x = a_over_a_non_rel;
+
+      // printf("a: %f, x: %f \n",a_over_a_non_rel,x);
+
+      class_call(array_interpolate_spline(
+                     pba->x_values,
+                     pba->size_x,
+                     pba->dist_table,
+                     pba->d2dist_dx2_table,
+                     8,
+                     x,
+                     &last_index_2,
+                     vec,
+                     8,
+                     pba->error_message),
+                 pba->error_message,
+                 pba->error_message);
+    }
+    else if (a_over_a_non_rel > pba->a_over_a_non_rel_max)
+    {
+      x = a_over_a_non_rel;
+      for (i = 0; i < 8; i++)
+        vec[i] = 0.;
+    }
+    else if (a_over_a_non_rel < pba->a_over_a_non_rel_min)
+    {
+      x = a_over_a_non_rel;
+      vec[0] = 1.;
+      vec[1] = 1.;
+      vec[2] = 0.;
+      vec[3] = 0.;
+      vec[4] = 1.;
+      vec[5] = 1.;
+      vec[6] = 0.;
+      vec[7] = 0.;
+    }
+
+    rhohat = vec[0];
+    phat = vec[1];
+    drhohat_dx = vec[2];
+    dphat_dx = vec[3];
+    free(vec);
+
+    if (rho != NULL)
+      *rho = pba->NEDE_norm * (1. + pba->NEDE_rg * rhohat) / pow(a, 4.);
+    if (p != NULL)
+      *p = pba->NEDE_norm * (1. + pba->NEDE_rg * phat) / pow(a, 4.) / 3.;
+    if (w != NULL)
+      *w = 1. / 3. * (1. + pba->NEDE_rg * phat) / (1. + pba->NEDE_rg * rhohat);
+    if (ca2 != NULL)
+      *ca2 = 1. / 3. * (1. + pba->NEDE_rg * phat - x / 4. * dphat_dx) / (1. + pba->NEDE_rg * rhohat - x / 4. * drhohat_dx);
+    if (dw_over_da != NULL)
+      *dw_over_da = 0.0;
+
+    if (a_over_a_non_rel == 1)
+      printf("x: %f, rhohat: %f ,phat: %f \n", x, rhohat, phat);
+  }
+
+  return _SUCCESS_;
+}
+
+int background_NEDE_init_distr_tables(
+    struct precision *ppr,
+    struct background *pba)
+{
+  FILE *distr_file;
+  int row, col, status, last_index;
+  double tmp, x, rho, p;
+
+  pba->a_non_rel = 1. / (1. + pba->mass_over_q0_NEDE);
+
+  /*
+  distr_file = fopen(pba->thermal_dist_path, "r");
+  class_test(distr_file == NULL, pba->error_message,
+             "Could not open Dist.dat!");
+
+  for (row = 0, status = 1; status == 1; row++)
+  {
+    for (col = 0; col < 9; col++)
+      status = fscanf(distr_file, "%lf", &tmp);
+  }
+  rewind(distr_file);
+  pba->size_x = row - 1;
+*/
+
+  pba->size_x = dist_table_length;
+
+  // printf("%d \n", pba->size_x);
+
+  class_alloc(pba->dist_table, sizeof(double) * pba->size_x * 8, pba->error_message);
+  class_alloc(pba->d2dist_dx2_table, sizeof(double) * pba->size_x * 8, pba->error_message);
+  class_alloc(pba->x_values, sizeof(double) * pba->size_x, pba->error_message);
+  class_alloc(pba->a_over_a_non_rel_table, sizeof(double) * pba->size_x, pba->error_message);
+  class_alloc(pba->d2x_da2_table, sizeof(double) * pba->size_x, pba->error_message);
+  class_alloc(pba->NEDE_vec, sizeof(double) * 8, pba->error_message);
+
+  for (row = 0; row < pba->size_x; row++)
+  {
+    for (col = 0; col < 9; col++)
+    {
+      // pba->dist_table[row * pba->size_x + col]=1;
+      if (col == 0)
+        // status = fscanf(distr_file, "%lf", &(pba->x_values[row]));
+        pba->x_values[row] = dist_table_full[row][0];
+      else
+        // status = fscanf(distr_file, "%lf", &(pba->dist_table[row * 8 + col - 1]));
+        pba->dist_table[row * 8 + col - 1] = dist_table_full[row][col];
+    }
+    rho = (pba->dist_table[row * 8 + 0]);
+    p = (pba->dist_table[row * 8 + 1]);
+    pba->a_over_a_non_rel_table[row] = pba->x_values[row] * pow(1. + pba->NEDE_rg / 4. * (3. * rho + p), -1. / 3.);
+    // printf("a: %f, x: %f \n",pba->a_over_a_non_rel_table[row],pba->x_values[row]);
+  }
+  // fclose(distr_file);
+
+  pba->a_over_a_non_rel_max = pba->a_over_a_non_rel_table[pba->size_x - 1];
+  pba->a_over_a_non_rel_min = pba->a_over_a_non_rel_table[0];
+
+  // printf("amax: %f, amin: %f \n", pba->a_over_a_non_rel_max, pba->a_over_a_non_rel_min);
+  // printf("dist_table: %f \n", dist_table_full[50][2]);
+
+  class_call(array_spline_table_lines(pba->x_values,
+                                      pba->size_x,
+                                      pba->dist_table,
+                                      8,
+                                      pba->d2dist_dx2_table,
+                                      _SPLINE_EST_DERIV_,
+                                      pba->error_message),
+             pba->error_message,
+             pba->error_message);
+
+  class_call(array_spline_table_lines(pba->a_over_a_non_rel_table,
+                                      pba->size_x,
+                                      pba->x_values,
+                                      1,
+                                      pba->d2x_da2_table,
+                                      _SPLINE_EST_DERIV_,
+                                      pba->error_message),
+             pba->error_message,
+             pba->error_message);
+
+  /*
+  class_call(background_quantities_NEDE(pba, 1., &rho,&p,&w,&cs2),
+             pba->error_message,
+             pba->error_message);
+
+  printf("rho: %f \n", rho);
+  */
+
+  return _SUCCESS_;
+}
+
 /**
  * This function finds optimal quadrature weights for each ncdm
  * species
@@ -1894,6 +2118,7 @@ int background_solve(
   double delta_z;
   double a;
   double d;
+  double w_NEDE, ca2_NEDE;
 
   bpaw.pba = pba;
   class_alloc(pvecback, pba->bg_size * sizeof(double), pba->error_message);
@@ -1982,7 +2207,7 @@ int background_solve(
         else
           pba->Omega_trigger_decay = 0.;
 
-        if (pba->background_verbose > 0)
+        if (pba->background_verbose > -1)
         {
           printf("New EDE decayed at redshift: %f ; fraction New EDE: %f; fraction trigger field: %e \n", pba->z_decay, pba->Omega_NEDE * pow(pba->H0, 2) / (pow(pvecback[pba->index_bg_H], 2)), pba->Omega_trigger_decay * pow(pba->H0, 2) / pow(pvecback[pba->index_bg_H], 2));
         }
@@ -1992,7 +2217,7 @@ int background_solve(
       if ((1. / a - 1. < pba->z_decay + delta_z) && (1. / a - 1. > pba->z_decay - delta_z) && (pba->z_decay > 1.))
       {
         // printf("decay: %f, a: %e, z_decay: %e, counter: %d \n", 1./a - 1.,a,pba->z_decay,d);
-        d = abs(1. / a - 1. - pba->z_decay) / delta_z;
+        d = fabs(1. / a - 1. - pba->z_decay) / delta_z;
         tau_end = tau_start + ppr->back_integration_stepsize / (1 + ppr->decay_res_enhancement * exp(-d * 6)) / (pvecback_integration[pba->index_bi_a] * pvecback[pba->index_bg_H]);
       }
     }
@@ -2215,10 +2440,26 @@ int background_solve(
     if (pba->has_NEDE == _TRUE_)
     {
 
-      printf("  -> New EDE details:\n");
+      printf("  -> NEDE details:\n");
       printf("     -> Percolation trigger (H/m): %f \n", pba->Bubble_trigger_H_over_m);
       printf("     -> closure check: H/H0-1: %e \n", pvecback[pba->index_bg_H] / pba->H0 - 1);
-      printf("     -> eos NEDE: omega = %e \n", pba->three_eos_NEDE / 3.);
+
+      if (pba->NEDE_fld_nature == NEDE_fld_A)
+        printf("     -> Scenario A with eos NEDE: 3*w = %e \n", pba->three_eos_NEDE);
+
+      if (pba->NEDE_fld_nature == NEDE_fld_B)
+        printf("     -> Scenario B with mass: m/q0 = %e \n", pba->mass_over_q0_NEDE);
+
+      if (pba->NEDE_fld_nature == NEDE_fld_BIII)
+      {
+
+        class_call(background_quantities_NEDE(pba, 1. / (pba->z_decay + 1.), 0, NULL, NULL, &w_NEDE, NULL, &ca2_NEDE),
+                   pba->error_message,
+                   pba->error_message);
+
+        printf("     -> Scenario BIII with (f_NEDE[%%],h,z_decay,z_rel)=(%.2f,%.2f,%d,%d) \n", 100 * pba->f_NEDE, pba->h * 100, (int)pba->z_decay, (int)pba->mass_over_q0_NEDE);
+        printf("     -> Derived quantities at decay time: (eos,ca2) = (%.2f,%.2f) \n", w_NEDE, ca2_NEDE);
+      }
 
       printf("     -> resolution_enhancement: %e \n", ppr->decay_res_enhancement);
       if (pba->has_NEDE_trigger == _TRUE_)
@@ -2738,8 +2979,8 @@ int background_derivs(
     double tau,
     double *y,  /* vector with argument y[index_bi] (must be already allocated with size pba->bi_size) */
     double *dy, /* vector with argument dy[index_bi]
-                   (must be already allocated with
-                   size pba->bi_size) */
+                                     (must be already allocated with
+                                     size pba->bi_size) */
     void *parameters_and_workspace,
     ErrorMsg error_message)
 {
