diff --git a/source/input.c b/source/input.c
index d26e9be1..ae943131 100644
--- a/source/input.c
+++ b/source/input.c
@@ -223,6 +223,7 @@ int input_init(
   double xzero;
   int target_indices[_NUM_TARGETS_];
   double *dxdF, *x_inout;
+  double additional_return_value;
 
   char string1[_ARGUMENT_LENGTH_MAX_];
   FILE *param_output;
@@ -283,9 +284,9 @@ int input_init(
    */
 
   char *const target_namestrings[] = {"100*theta_s", "Omega_dcdmdr", "omega_dcdmdr",
-                                      "Omega_scf", "Omega_ini_dcdm", "omega_ini_dcdm", "sigma8"};
+                                      "Omega_scf", "Omega_ini_dcdm", "omega_ini_dcdm", "sigma8", "z_decay_NEDE"};
   char *const unknown_namestrings[] = {"h", "Omega_ini_dcdm", "Omega_ini_dcdm",
-                                       "scf_shooting_parameter", "Omega_dcdmdr", "omega_dcdmdr", "A_s"};
+                                       "scf_shooting_parameter", "Omega_dcdmdr", "omega_dcdmdr", "A_s", "NEDE_trigger_mass"};
   enum computation_stage target_cs[] = {cs_thermodynamics, cs_background, cs_background,
                                         cs_background, cs_background, cs_background, cs_nonlinear};
 
@@ -399,7 +400,6 @@ int input_init(
       class_call_try(input_find_root(&xzero,
                                      &fevals,
                                      &fzw,
-                                     ppr->tol_shooting_1d,
                                      errmsg),
                      errmsg,
                      pba->shooting_error,
@@ -578,20 +578,6 @@ int input_init(
     }
   }
 
-  if (pnl->has_pk_eq == _TRUE_)
-  {
-
-    if (input_verbose > 0)
-    {
-      printf(" -> since you want to use Halofit with a non-zero wa_fld and the Pk_equal method,\n");
-      printf("    calling background module to extract the effective w(tau), Omega_m(tau) parameters");
-      printf("    required by this method\n");
-    }
-    class_call(input_prepare_pk_eq(ppr, pba, pth, pnl, input_verbose, errmsg),
-               errmsg,
-               errmsg);
-  }
-
   return _SUCCESS_;
 }
 int input_read_precisions(
@@ -654,7 +640,11 @@ int input_read_parameters(
   int flag1, flag2, flag3;
   double param1, param2, param3;
   double param_NEDE;
+  double rho_NEDE, w_NEDE;
+  double ca2;
   int flag_NEDE;
+  int flag_NEDE_2;
+  int flag_NEDE_4;
   char string_NEDE[_ARGUMENT_LENGTH_MAX_];
 
   int N_ncdm = 0, n, entries_read;
@@ -1363,8 +1353,10 @@ int input_read_parameters(
   /*new convention*/
 
   class_read_double("f_NEDE", pba->f_NEDE);
+  class_read_double("z_decay_NEDE", pba->z_decay);
   class_read_double("NEDE_trigger_mass", pba->NEDE_trigger_mass);
   class_read_double("three_eos_NEDE", pba->three_eos_NEDE);
+  class_read_double("mass_over_q0_NEDE", pba->mass_over_q0_NEDE);
   class_read_double("three_ceff2_NEDE", ppt->three_ceff2_NEDE);
   class_read_double("three_cvis2_NEDE", ppt->three_cvis2_NEDE);
   class_read_double("H_over_m_NEDE", pba->Bubble_trigger_H_over_m);
@@ -1389,10 +1381,32 @@ int input_read_parameters(
     }
   }
 
+  /*NEDE: Here we decide whether NEDE decays according to scenario A or B. Default: Scneario A*/
+
+  class_call(parser_read_string(pfc, "NEDE_fld_nature", &string_NEDE, &flag_NEDE_4, errmsg),
+             errmsg,
+             errmsg);
+
+  if (flag_NEDE_4 == _TRUE_)
+  {
+    if ((strstr(string_NEDE, "A") != NULL) || (strstr(string1, "stiff") != NULL) || (strstr(string1, "Scenario_A") != NULL) || (strstr(string1, "const") != NULL))
+    {
+      pba->NEDE_fld_nature = NEDE_fld_A;
+    }
+    if ((strstr(string_NEDE, "B") != NULL) || (strstr(string1, "decay") != NULL) || (strstr(string1, "Scenario_B") != NULL))
+    {
+      pba->NEDE_fld_nature = NEDE_fld_B;
+    }
+    if (strstr(string_NEDE, "BIII") != NULL)
+    {
+      pba->NEDE_fld_nature = NEDE_fld_BIII;
+    }
+  }
+
   if ((pba->Omega_NEDE > 0) || (pba->f_NEDE > 0))
   {
-    class_test(pba->NEDE_trigger_mass == 0, errmsg,
-               "In input file, NEDE_trigger_mass>0  needs to be specified for NEDE.");
+    // class_test(pba->NEDE_trigger_mass==0,errmsg,
+    //     "In input file, NEDE_trigger_mass>0  needs to be specified for NEDE.");
 
     if (pba->Omega_NEDE == 0)
       pba->Omega_NEDE = pba->f_NEDE * pow(pba->NEDE_trigger_mass * pba->Bubble_trigger_H_over_m / pba->H0, 2);
@@ -1405,39 +1419,55 @@ int input_read_parameters(
       pba->phi_prime_ini_trigger = 0; // This value is set to the attractor later.
     }
 
-    class_test(pba->f_NEDE > 0.5, errmsg,
+    class_test(pba->f_NEDE > 0.4, errmsg,
                "Choose a smaller amount of NEDE as the code has not been tested for f_NEDE > 0.4.");
 
-    /*Here we do a first run of the background module to get a good guess for z_decay. For this we do not need a super precise value of Omega_lambda as the decay happens during rad domination when Omega_lambda is subdom.. */
-
-    class_read_double("background_verbose", pba->background_verbose);
-    class_read_double("back_integration_stepsize", ppr->back_integration_stepsize);
+    if (pba->NEDE_fld_nature == NEDE_fld_A)
+      pba->Omega0_NEDE = pba->Omega_NEDE * pow(1. / (1. + pba->z_decay), (3. + pba->three_eos_NEDE));
+    else if (pba->NEDE_fld_nature == NEDE_fld_B)
+    {
+      pba->Omega0_NEDE = pba->Omega_NEDE * pow(1. + pba->z_decay, -4) * pow((1. + pow(pba->mass_over_q0_NEDE, 2)) / (1. + pow(pba->mass_over_q0_NEDE / (1. + pba->z_decay), 2)), 0.5);
+    }
+    else if (pba->NEDE_fld_nature == NEDE_fld_BIII)
+    {
+      // printf("hallo0 \n");
+      flag_NEDE_2 = _FALSE_;
+      class_call(parser_read_string(pfc, "NEDE_dist_path", &string_NEDE, &flag_NEDE_2, errmsg),
+                 errmsg,
+                 errmsg);
+      if (flag_NEDE_2 == _TRUE_)
+      {
+        // printf("hallo1 \n");
+        sprintf(pba->thermal_dist_path, "%s", string_NEDE);
+        // printf("%s \n", string_NEDE);
+      }
+      // printf("hallo2 \n");
+      // printf("%s \n", string_NEDE);
 
-    // initial guess for decay time
-    // pba->z_decay = 1420.0 * pow(1-pba->f_NEDE,1./4.) * pba->Bubble_trigger_H_over_m * pow(pba->NEDE_trigger_mass,0.5);
-    // pba->a_decay = 1./(1.+pba->z_decay);
-    // pba->Omega0_NEDE = pba->Omega_NEDE/pow(1+pba->z_decay,3.+pba->three_eos_NEDE);
+      class_call(background_NEDE_init_distr_tables(ppr, pba),
+                 pba->error_message,
+                 errmsg);
 
-    pba->Omega0_NEDE = 0; // Sufficiently good initial guess as NEDE decays quickly.
-    pba->Omega0_lambda = 1. - pba->Omega0_k - Omega_tot - pba->Omega0_NEDE;
+      class_call(background_quantities_NEDE(pba, 1. / (1. + pba->z_decay), 0., &rho_NEDE, NULL, &w_NEDE, NULL, NULL),
+                 pba->error_message,
+                 pba->error_message);
 
-    if (pba->background_verbose > 1)
-    {
-      printf("trigger mass: %f, Omega_EDE: %e, EOS: %f \n", pba->NEDE_trigger_mass, pba->Omega_NEDE, pba->three_eos_NEDE / 3.);
-      printf("First run to estimate Omega0_NEDE and z_decay. Initial estimate is z_decay = %e and Omega0_NEDE = %e \n", pba->z_decay, pba->Omega0_NEDE);
-    }
+      pba->NEDE_norm = pba->Omega_NEDE * pba->H0 * pba->H0 / rho_NEDE;
 
-    class_call(find_z_decay(ppr, pba, errmsg), errmsg, errmsg);
+      class_call(background_quantities_NEDE(pba, 1., 0., &rho_NEDE, NULL, &w_NEDE, NULL, &ca2),
+                 pba->error_message,
+                 pba->error_message);
 
-    pba->Omega0_lambda = 1. - pba->Omega0_k - Omega_tot - pba->Omega0_NEDE - pba->Omega0_trigger;
+      pba->Omega0_NEDE = rho_NEDE / pba->H0 / pba->H0;
 
-    if (pba->background_verbose > 1)
-      printf("Second run to estimate Omega0_NEDE and z_decay. Second estimate is z_decay = %e and Omega0_NEDE = %e \n", pba->z_decay, pba->Omega0_NEDE);
+      class_call(background_quantities_NEDE(pba, pba->a_non_rel, 0., &rho_NEDE, NULL, &w_NEDE, NULL, &ca2),
+                 pba->error_message,
+                 pba->error_message);
 
-    class_call(find_z_decay(ppr, pba, errmsg), errmsg, errmsg);
+      printf("rho: %E, w: %f, ca2: %f \n", rho_NEDE / pba->H0 / pba->H0, w_NEDE, ca2);
+    }
 
-    if (pba->background_verbose > 1)
-      printf("Final  estimate is z_decay = %e and Omega0_NEDE = %e \n", pba->z_decay, pba->Omega0_NEDE);
+    // printf("zdecay: %f \n", pba->z_decay);
 
     Omega_tot += pba->Omega0_NEDE;
     Omega_tot += pba->Omega0_trigger;
@@ -3054,7 +3084,7 @@ int input_read_parameters(
                errmsg,
                errmsg);
 
-    if ((flag1 == _TRUE_))
+    if (flag1 == _TRUE_)
     {
       if ((strstr(string1, "analytic") != NULL))
       {
@@ -3075,7 +3105,7 @@ int input_read_parameters(
                errmsg,
                errmsg);
 
-    if ((flag1 == _TRUE_))
+    if (flag1 == _TRUE_)
     {
       if ((strstr(string1, "analytic") != NULL))
       {
@@ -3490,7 +3520,7 @@ int input_read_parameters(
   /** - (i.5) special steps if we want Halofit with wa_fld non-zero:
       so-called "Pk_equal method" of 0810.0190 and 1601.07230 */
 
-  if (pnl->method == nl_halofit)
+  if ((pnl->method == nl_halofit) && (pba->Omega0_fld != 0.) && (pba->wa_fld != 0.))
   {
 
     class_call(parser_read_string(pfc, "pk_eq", &string1, &flag1, errmsg),
@@ -3500,14 +3530,26 @@ int input_read_parameters(
     if ((flag1 == _TRUE_) && ((strstr(string1, "y") != NULL) || (strstr(string1, "Y") != NULL)))
     {
 
-      if ((pba->Omega0_fld != 0.) && (pba->wa_fld != 0.))
-      {
+      pnl->has_pk_eq = _TRUE_;
+    }
+  }
 
-        pnl->has_pk_eq = _TRUE_;
-      }
+  if (pnl->has_pk_eq == _TRUE_)
+  {
+
+    if (input_verbose > 0)
+    {
+      printf(" -> since you want to use Halofit with a non-zero wa_fld, calling background module to\n");
+      printf("    extract the effective w(tau), Omega_m(tau) parameters required by the Pk_equal method\n");
     }
+    class_call(input_prepare_pk_eq(ppr, pba, pth, pnl, input_verbose, errmsg),
+               errmsg,
+               errmsg);
   }
 
+  printf("h: %f, omega_b: %f, omega_cdm: %f, ns: %f, ln10^10As: %f, tau: %f, mass: %f \n", pba->h, pba->Omega0_b * pba->h * pba->h,
+         pba->Omega0_cdm * pba->h * pba->h, ppm->n_s, log(ppm->A_s / 1.e-10), pth->tau_reio, pba->mass_over_q0_NEDE);
+
   return _SUCCESS_;
 }
 
@@ -3625,9 +3667,16 @@ int input_default_params(
   pba->z_decay = 0.;
   pba->a_decay = 0.;
 
+  pba->NEDE_norm = 1;
+  pba->NEDE_rg = 8. / 7.;
+  sprintf(pba->thermal_dist_path, "thermal_dist/Dist.dat");
+
   ppt->three_ceff2_NEDE = 2.; // Default: matches adiabatic sound speed.
   ppt->three_cvis2_NEDE = 0.;
 
+  pba->NEDE_fld_nature = NEDE_fld_A;
+  pba->mass_over_q0_NEDE = 0;
+
   /** - thermodynamics structure */
 
   pth->YHe = _BBN_;
@@ -4148,7 +4197,7 @@ int input_try_unknown_parameters(double *unknown_parameter,
   }
   if (compute_sigma8 == _TRUE_)
   {
-    pt.k_max_for_pk = 10.0; // increased in June 2020 for higher accuracy
+    pt.k_max_for_pk = 1.0;
     pt.has_pk_matter = _TRUE_;
     pt.has_perturbations = _TRUE_;
     pt.has_cl_cmb_temperature = _FALSE_;
@@ -4159,8 +4208,6 @@ int input_try_unknown_parameters(double *unknown_parameter,
     pt.has_cl_lensing_potential = _FALSE_;
     pt.has_density_transfers = _FALSE_;
     pt.has_velocity_transfers = _FALSE_;
-    nl.has_pk_eq = _FALSE_; // not needed since sigma8 is derived from linear P(k)
-    nl.method = nl_none;    // not needed since sigma8 is derived from linear P(k)
   }
 
   /** - Shoot forward into class up to required stage */
@@ -4286,6 +4333,11 @@ int input_try_unknown_parameters(double *unknown_parameter,
     case sigma8:
       output[i] = nl.sigma8[nl.index_pk_m] - pfzw->target_value[i];
       break;
+    case z_decay_NEDE: // NEDE shooting
+      output[i] = ba.z_decay - pfzw->target_value[i];
+      // printf("z_decay: %f",ba.z_decay);
+      // z_decay_temp=ba.z_decay;
+      break;
     }
   }
 
@@ -4485,8 +4537,12 @@ int input_get_guess(double *xguess,
       xguess[index_guess] = 2.43e-9 / 0.87659 * pfzw->target_value[index_guess];
       dxdy[index_guess] = 2.43e-9 / 0.87659;
       break;
+
+    case z_decay_NEDE:
+      xguess[index_guess] = pow(pfzw->target_value[index_guess], 2.) / pow(ba.Bubble_trigger_H_over_m * 1200., 2.);
+      dxdy[index_guess] = 2 * pfzw->target_value[index_guess] / pow(ba.Bubble_trigger_H_over_m * 1200., 2.);
     }
-    // printf("xguess = %g\n",xguess[index_guess]);
+    printf("xguess = %g\n", xguess[index_guess]);
   }
 
   for (i = 0; i < pfzw->fc.size; i++)
@@ -4503,7 +4559,6 @@ int input_get_guess(double *xguess,
 int input_find_root(double *xzero,
                     int *fevals,
                     struct fzerofun_workspace *pfzw,
-                    double tol,
                     ErrorMsg errmsg)
 {
   double x1, x2, f1, f2, dxdy, dx;
@@ -4574,7 +4629,7 @@ int input_find_root(double *xzero,
   class_call(class_fzero_ridder(input_fzerofun_1d,
                                 x1,
                                 x2,
-                                tol * MAX(fabs(x1), fabs(x2)),
+                                1e-5 * MAX(fabs(x1), fabs(x2)),
                                 pfzw,
                                 &f1,
                                 &f2,
